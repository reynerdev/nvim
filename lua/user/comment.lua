require("Comment").setup {
  pre_hook = require("ts_context_commentstring.integrations.comment_nvim").create_pre_hook(),
  -- ignore = "^$",
  -- pre_hook = function(ctx)
  --   -- For inlay hints
  --   -- local line_start = (ctx.srow or ctx.range.srow) - 1
  --   -- local line_end = ctx.erow or ctx.range.erow
  --   -- require("lsp-inlayhints.core").clear(0, line_start, line_end)
  --
  --   require("ts_context_commentstring.integrations.comment_nvim").create_pre_hook()
  --
  --   if vim.bo.filetype == "javascript" or vim.bo.filetype == "typescript" then
  --     local U = require "Comment.utils"
  --
  --     -- Determine whether to use linewise or blockwise commentstring
  --     local type = ctx.ctype == U.ctype.linewise and "__default" or "__multiline"
  --
  --     -- Determine the location where to calculate commentstring from
  --     local location = nil
  --     if ctx.ctype == U.ctype.blockwise then
  --       location = require("ts_context_commentstring.utils").get_cursor_location()
  --     elseif ctx.cmotion == U.cmotion.v or ctx.cmotion == U.cmotion.V then
  --       location = require("ts_context_commentstring.utils").get_visual_start_location()
  --     end
  --
  --     return require("ts_context_commentstring.internal").calculate_commentstring {
  --       key = type,
  --       location = location,
  --     }
  --   end
  -- end,
}

-- local status_ok, comment = pcall(require, "Comment")
-- if not status_ok then
--   return
-- end
--
-- -- local pre_hook
-- -- local loaded, ts_comment = pcall(require, "ts_context_commentstring.integrations.comment_nvim")
--
-- -- if loaded and ts_comment then
-- --   pre_hook = ts_comment.create_pre_hook()
-- -- end
--
-- local status_ok_1, _ = pcall(require, "lsp-inlayhints")
-- if not status_ok_1 then
--   return
-- end
--
-- comment.setup {
--   active = true,
--   on_config_done = nil,
--   ---Add a space b/w comment and the line
--   ---@type boolean
--   padding = true,
--
--   ---Whether cursor should stay at the
--   ---same position. Only works in NORMAL
--   ---mode mappings
--   sticky = true,
--
--   ---Lines to be ignored while comment/uncomment.
--   ---Could be a regex string or a function that returns a regex string.
--   ---Example: Use '^$' to ignore empty lines
--   ---@type string|function
--   ignore = "^$",
--
--   ---Whether to create basic (operator-pending) and extra mappings for NORMAL/VISUAL mode
--   ---@type table
--   mappings = {
--     ---operator-pending mapping
--     ---Includes `gcc`, `gcb`, `gc[count]{motion}` and `gb[count]{motion}`
--     basic = true,
--     ---Extra mapping
--     ---Includes `gco`, `gcO`, `gcA`
--     extra = true,
--   },
--
--   ---LHS of line and block comment toggle mapping in NORMAL/VISUAL mode
--   ---@type table
--   toggler = {
--     ---line-comment toggle
--     line = "gcc",
--     ---block-comment toggle
--     block = "gbc",
--   },
--
--   ---LHS of line and block comment operator-mode mapping in NORMAL/VISUAL mode
--   ---@type table
--   opleader = {
--     ---line-comment opfunc mapping
--     line = "gc",
--     ---block-comment opfunc mapping
--     block = "gb",
--   },
--
--   ---LHS of extra mappings
--   ---@type table
--   extra = {
--     ---Add comment on the line above
--     above = "gcO",
--     ---Add comment on the line below
--     below = "gco",
--     ---Add comment at the end of line
--     eol = "gcA",
--   },
--
--   ---Pre-hook, called before commenting the line
--   ---@type function|nil
--
--   ---Post-hook, called after commenting is done
--   ---@type function|nil
--   -- pre_hook = pre_hook,
--   pre_hook = require("ts_context_commentstring.integrations.comment_nvim").create_pre_hook(),
--   -- pre_hook = function(ctx)
--   --   local U = require "Comment.utils"
--   --
--   --   local location = nil
--   --   if ctx.ctype == U.ctype.block then
--   --     location = require("ts_context_commentstring.utils").get_cursor_location()
--   --   elseif ctx.cmotion == U.cmotion.v or ctx.cmotion == U.cmotion.V then
--   --     location = require("ts_context_commentstring.utils").get_visual_start_location()
--   --   end
--   --
--   --   return require("ts_context_commentstring.internal").calculate_commentstring {
--   --     key = ctx.ctype == U.ctype.line and "__default" or "__multiline",
--   --     location = location,
--   --   }
--   -- end,
--
--   -- pre_hook = require('ts_context_commentstring.integrations.comment_nvim').create_pre_hook()
--   -- ignore = "^$",
--   -- pre_hook = function(ctx)
--   --   local U = require "Comment.utils"
--   --
--   --   local location = nil
--   --   if ctx.ctype == U.ctype.blockwise then
--   --     location = require("ts_context_commentstring.utils").get_cursor_location()
--   --   elseif ctx.cmotion == U.cmotion.v or ctx.cmotion == U.cmotion.V then
--   --     location = require("ts_context_commentstring.utils").get_visual_start_location()
--   --   end
--   --
--   --   return require("ts_context_commentstring.internal").calculate_commentstring {
--   --     key = ctx.ctype == U.ctype.linewise and "__default" or "__multiline",
--   --     location = location,
--   --   }
--   -- end,
--   -- pre_hook = function(ctx)
--   --   -- For inlay hints
--   --   local line_start = (ctx.srow or ctx.range.srow) - 1
--   --   local line_end = ctx.erow or ctx.range.erow
--   --   require("lsp-inlayhints.core").clear(0, line_start, line_end)
--   --
--   --   require("ts_context_commentstring.integrations.comment_nvim").create_pre_hook()
--   --
--   --   if vim.bo.filetype == "javascript" or vim.bo.filetype == "typescript" then
--   --     local U = require "Comment.utils"
--   --
--   --     -- Determine whether to use linewise or blockwise commentstring
--   --     local type = ctx.ctype == U.ctype.linewise and "__default" or "__multiline"
--   --
--   --     -- Determine the location where to calculate commentstring from
--   --     local location = nil
--   --     if ctx.ctype == U.ctype.blockwise then
--   --       location = require("ts_context_commentstring.utils").get_cursor_location()
--   --     elseif ctx.cmotion == U.cmotion.v or ctx.cmotion == U.cmotion.V then
--   --       location = require("ts_context_commentstring.utils").get_visual_start_location()
--   --     end
--   --
--   --     return require("ts_context_commentstring.internal").calculate_commentstring {
--   --       key = type,
--   --       location = location,
--   --     }
--   --   end
--   -- end,
-- }
